<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="d3-scale-radial.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<title>Musical Ties</title>

<div style="display: flex; width: 100vw; height: 100vh; margin: 0; padding: 0; max-width:100%; max-height:100%;">
  <div style="display: flex; width: 100%; height: 100%;">

    <svg width="100%" height="100%"></svg>
  </div>
</div>


<style>

</style>

<script>


d3.json("https://raw.githubusercontent.com/6859-sp21/final-project-musical-ties/main/data/playListData.json").then(playlistData => {
d3.json("https://raw.githubusercontent.com/6859-sp21/final-project-musical-ties/main/data/trackData.json").then(trackData => {

  // trying to just visualize one playlist, so one stacked bar for every song 
  var examplePlaylist = playlistData[Object.keys(playlistData)[0]]; 
  var features = ["valence", "danceability", "speechiness", "liveness", "energy"]; 
  
  // TODO width and height will probs need to be different when not in full screen viewing
  var svg = d3.select("svg").attr("preserveAspectRatio", "xMinYMin meet"),
    width = $("svg").width(),
    height = $("svg").height(),
    innerRadius = Math.min(width, height) / 6,
    outerRadius = Math.min(width, height) / 2,
    g = svg.append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"); 

  var x = d3.scaleBand()
    .range([0, 2 * Math.PI])
    .align(0)
    .domain(examplePlaylist["track_ids"]);

  var y = d3.scaleRadial()
    .range([innerRadius, outerRadius])
    .domain([0, 5]);

  var colors = ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]; 

  features.forEach((feature, i) => {
    g.append('g')
      .selectAll('path')
      .data(examplePlaylist['track_ids'])
      .enter()
      .append('path')
      .attr("fill", colors[i])
        .attr("d", d3.arc() 
            .innerRadius(function(d) { return y(getFeatureStartPos(d, i)); })
            .outerRadius(function(d) { return y(getFeatureEndPos(d, i)); })
            .startAngle(function(d) { return x(d); })
            .endAngle(function(d) { return x(d) + x.bandwidth(); })
            .padAngle(0.01)
            .padRadius(innerRadius)
            )
            .on("mouseover", function(event, d, i){
              displaySongInfoPlaylist(d, i)
            })
            .on("mouseout", function(event, d, i){
              // TODO i'm not sure this will work when we scale up
              updatePlaylistDisplayInfo([examplePlaylist["name"]])
            })
    }); 

    function displaySongInfoPlaylist(songID, featureIndex){
      var highlightedFeature = features[featureIndex]; 
      var songInfo = trackData[songID]; 
      var songFeatures = [songInfo['title']]; 
      for(var i = 0; i < features.length; i++){
        let info = "" + features[i] + " " + songInfo['features'][features[i]]; 
        songFeatures.push(info); 
      }
      updatePlaylistDisplayInfo(songFeatures); 
    }

    function updatePlaylistDisplayInfo(title){
      // middle of playlist text
      g.selectAll("text.playlistInfo").data(title).join(
        enter => enter.append("text"),
        update => update,
        exit   => exit.remove()
      )
      .style("fill", "black")
      .attr("stroke-width", 2)
      .attr("fill-opacity", .4)
      .classed('playlistInfo', true)
      .text(d => d)

      if(title.length > 1){
        g.selectAll("text.playlistInfo").attr("transform", (d, i) => `translate(0,${(i * 20)})`); 
      }
      else{
        g.selectAll("text.playlistInfo").attr("transform", `translate(0,0)`);
      }

      
    }

    updatePlaylistDisplayInfo([examplePlaylist["name"]]); 



    // text in middle
    // legend = g => g.append('g')
    //   .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
    //   .selectAll('g').data(examplePlaylist)
    //   .join('g')
    //   .call(g => g.append("text")
    //   .attr('x', width / 2)
    //   .attr('y', height / 2)
    //   .text("HELLOOOOOO")); 


    function getFeatureStartPos(songId, featureIndex){
      var total = 0;  
      for(var i = 0; i < featureIndex; i++){
        total += trackData[songId]["features"][features[i]];
      }
      return total; 
    }

    function getFeatureEndPos(songId, featureIndex){
      var total = getFeatureStartPos(songId, featureIndex);  
      total += trackData[songId]["features"][features[featureIndex]];
      return total; 
    }

  //     var label = g.append("g")
  //       .selectAll("g")
  //       .data(data)
  //       .enter().append("g")
  //         .attr("text-anchor", "middle")
  //         .attr("transform", function(d) { return "rotate(" + ((x(d.State) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)"; });

  //     label.append("line")
  //         .attr("x2", -5)
  //         .attr("stroke", "#000");

  //     label.append("text")
  //         .attr("transform", function(d) { return (x(d.State) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(90)translate(0,16)" : "rotate(-90)translate(0,-9)"; })
  //         .text(function(d) { return d.State; });

  //     var yAxis = g.append("g")
  //         .attr("text-anchor", "middle");

  //     var yTick = yAxis
  //       .selectAll("g")
  //       .data(y.ticks(5).slice(1))
  //       .enter().append("g");

  //     yTick.append("circle")
  //         .attr("fill", "none")
  //         .attr("stroke", "#000")
  //         .attr("r", y);

  //     yTick.append("text")
  //         .attr("y", function(d) { return -y(d); })
  //         .attr("dy", "0.35em")
  //         .attr("fill", "none")
  //         .attr("stroke", "#fff")
  //         .attr("stroke-width", 5)
  //         .text(y.tickFormat(5, "s"));

  //     yTick.append("text")
  //         .attr("y", function(d) { return -y(d); })
  //         .attr("dy", "0.35em")
  //         .text(y.tickFormat(5, "s"));

  //     yAxis.append("text")
  //         .attr("y", function(d) { return -y(y.ticks(5).pop()); })
  //         .attr("dy", "-1em")
  //         .text("Population");

  //     var legend = g.append("g")
  //       .selectAll("g")
  //       .data(data.columns.slice(1).reverse())
  //       .enter().append("g")
  //         .attr("transform", function(d, i) { return "translate(-40," + (i - (data.columns.length - 1) / 2) * 20 + ")"; });

  //     legend.append("rect")
  //         .attr("width", 18)
  //         .attr("height", 18)
  //         .attr("fill", z);

  //     legend.append("text")
  //         .attr("x", 24)
  //         .attr("y", 9)
  //         .attr("dy", "0.35em")
  //         .text(function(d) { return d; });
  // // });


}); 
  
}); 




</script>