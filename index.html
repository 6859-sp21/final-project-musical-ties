<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="d3-scale-radial.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<title>Musical Ties</title>

<div style="display: flex; width: 100vw; height: 100vh; margin: 0; padding: 0; max-width:100%; max-height:100%;">
  <div style="display: flex; width: 100%; height: 100%;">

    <svg width="100%" height="100%"></svg>
  </div>
</div>


<style>

</style>

<script>


d3.json("https://raw.githubusercontent.com/6859-sp21/final-project-musical-ties/main/data/playListData.json").then(playlistData => {
d3.json("https://raw.githubusercontent.com/6859-sp21/final-project-musical-ties/main/data/trackData.json").then(trackData => {

  // trying to just visualize one playlist, so one stacked bar for every song 
  var examplePlaylist = playlistData[Object.keys(playlistData)[0]]; 
  var features = ["valence", "danceability", "speechiness", "liveness", "energy"]; 
  
  // TODO width and height will probs need to be different when not in full screen viewing
  var svg = d3.select("svg").attr("preserveAspectRatio", "xMinYMin meet"),
    width = $("svg").width(),
    height = $("svg").height(),
    innerRadius = Math.min(width, height) / 6,
    outerRadius = Math.min(width, height) / 2,
    g = svg.append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"); 

  var x = d3.scaleBand()
    .range([0, 2 * Math.PI])
    .align(0)
    .domain(examplePlaylist["track_ids"]);

  var y = d3.scaleRadial()
    .range([innerRadius, outerRadius])
    .domain([0, 5]);

  var colors = ["#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]; 
  var colorsBright = ["#aaa8e6", "#c69de3", "#db8cdb", "#ed8b80", "#ff9c5e", "#ffa83d"]; 

  function getBrighterByFeature(feature){
    var ind = features.indexOf(feature); 
    console.log(colorsBright[ind]); 
    return colorsBright[ind];
  }

  function getDarkerByFeature(feature){
    var ind = features.indexOf(feature); 
    return colors[ind];
  }

  // var colorsBright = ["#b7b6de", "#bd9fd1", "#cc89cc", "#db8279", "#f29f6b", "#ffba66"]; 
  var selectedSong = ""; 

  function drawPlaylist(){
    features.forEach((feature, i) => {
      g.append('g')
        .selectAll('path')
        .data(examplePlaylist['track_ids'])
        .join(
          enter => enter.append('path'),
          update => update,
          exit   => exit.remove()
        )
        .classed(feature, true)
        .style("fill", colors[i])
          .attr("d", d3.arc() 
              .innerRadius(function(d) { return y(getFeatureStartPos(d, i)); })
              .outerRadius(function(d) { return y(getFeatureEndPos(d, i)); })
              .startAngle(function(d) { return x(d); })
              .endAngle(function(d) { return x(d) + x.bandwidth(); })
              .padAngle(0.01)
              .padRadius(innerRadius)
              )
      }); 

      g.append('g')
        .selectAll('path')
        .data(examplePlaylist['track_ids'])
        .join(
          enter => enter.append('path'),
          update => update,
          exit   => exit.remove()
        )
        .attr("opacity","0")
        .attr("d", d3.arc() 
          .innerRadius(function(d) { return y(0); })
          .outerRadius(function(d) { return y(5); }) // this val could be improved but whatever for now
          .startAngle(function(d) { return x(d); })
          .endAngle(function(d) { return x(d) + x.bandwidth(); })
          .padAngle(0.01)
          .padRadius(innerRadius)
          )
        .on("mouseenter", function(event, d, i){
          displaySongInfoPlaylist(d, i); 
          var selectedSong = d; 
          svg.selectAll("path")
            .filter(d => d == selectedSong)
            // .style("fill", getBrighter(this.attr["class"]))
        })
        .on("mouseout", function(event, d, i){
          // TODO i'm not sure this will work when we scale up
          updatePlaylistDisplayInfo([examplePlaylist["name"]]);
          var selectedSong = d;
          svg.selectAll("path")
            .filter(d => d == selectedSong)
            // .style("fill", getDarker(this.style.fill))
        })


  }

    function displaySongInfoPlaylist(songID){
      var songInfo = trackData[songID]; 
      var songFeatures = [songInfo['title']]; 
      for(var i = 0; i < features.length; i++){
        let info = "" + features[i] + " " + songInfo['features'][features[i]]; 
        songFeatures.push(info); 
      }
      updatePlaylistDisplayInfo(songFeatures); 
    }

    function drawPlaylistLegend(){
      g.selectAll('rect.legend').data(features).join(
        enter => enter.append("rect"),
        update => update,
        exit   => exit.remove()
      )
      .style('cursor', 'pointer')
      .style("fill", function(d) {return colors[features.indexOf(d)]})
      .attr("stroke-width", 2)
      .attr("fill-opacity", .4)
      .attr("width", 18)
      .attr("height", 18)
      .classed('legend', true)
      .attr("opacity", "1")
      .text(d => d)
      .attr("transform", (d, i) => `translate(-20,${(i * 20 + 5)})`)
      .on("mouseenter", function(event, d){
        var objClass = "path." + d; 
        console.log(d); 
        var something = d; 
        console.log(d3.rgb(getBrighterByFeature(d))); 
        svg.selectAll(objClass).style("fill", getBrighterByFeature(d))
      })
      .on("mouseout", function(event, d){
        var objClass = "path." + d; 
        svg.selectAll(objClass).style("fill", getDarkerByFeature(d))
      })
      .on("click", function(event, d){
        var objClass = "path." + d; 
        examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], d); 
        // svg.selectAll(objClass).style("fill", getBrighter(this.style.fill))
        drawPlaylist(); 
        svg.selectAll(objClass).style("fill", getBrighterByFeature(d)); 
      })
    }

    drawPlaylistLegend(); 

    function updatePlaylistDisplayInfo(title){
      if(title.length == 1){
        for(var i = 0; i < features.length; i++){
          title.push(features[i]); 
        }
      }

      // middle of playlist text
      g.selectAll("text.playlistInfo").data(title).join(
        enter => enter.append("text"),
        update => update,
        exit   => exit.remove()
      )
      .style("fill", "black")
      .attr("stroke-width", 2)
      .attr("fill-opacity", .4)
      .classed('playlistInfo', true)
      .text(d => d)
      .attr("transform", (d, i) => `translate(0,${(i * 20)})`); 
    }

    function sortByFeature(songs, feature){
      // TODO might be better to not sort the original array? how do you get back to original config... hmm 
      songs.sort(function(a, b) {
        return trackData[a]["features"][feature] - trackData[b]["features"][feature]; 
      }); 

      svg.selectAll('path').data(examplePlaylist['track_ids']).exit().remove(); 

      x = d3.scaleBand()
        .range([0, 2 * Math.PI])
        .align(0)
        .domain(songs);
      return songs; 
    }
    console.log(examplePlaylist['track_ids']); 
    examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], 'energy'); 
    examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], 'liveness'); 
    examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], 'speechiness'); 
    examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], 'danceability'); 
    examplePlaylist['track_ids'] =  sortByFeature(examplePlaylist['track_ids'], 'valence'); 
    
    console.log(examplePlaylist['track_ids']); 
    drawPlaylist(); 

    updatePlaylistDisplayInfo([examplePlaylist["name"]]); 
    



    // text in middle
    // legend = g => g.append('g')
    //   .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
    //   .selectAll('g').data(examplePlaylist)
    //   .join('g')
    //   .call(g => g.append("text")
    //   .attr('x', width / 2)
    //   .attr('y', height / 2)
    //   .text("HELLOOOOOO")); 


    function getFeatureStartPos(songId, featureIndex){
      var total = 0;  
      for(var i = 0; i < featureIndex; i++){
        total += trackData[songId]["features"][features[i]];
      }
      return total; 
    }

    function getFeatureEndPos(songId, featureIndex){
      var total = getFeatureStartPos(songId, featureIndex);  
      total += trackData[songId]["features"][features[featureIndex]];
      return total; 
    }

  //     var label = g.append("g")
  //       .selectAll("g")
  //       .data(data)
  //       .enter().append("g")
  //         .attr("text-anchor", "middle")
  //         .attr("transform", function(d) { return "rotate(" + ((x(d.State) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)"; });

  //     label.append("line")
  //         .attr("x2", -5)
  //         .attr("stroke", "#000");

  //     label.append("text")
  //         .attr("transform", function(d) { return (x(d.State) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(90)translate(0,16)" : "rotate(-90)translate(0,-9)"; })
  //         .text(function(d) { return d.State; });

  //     var yAxis = g.append("g")
  //         .attr("text-anchor", "middle");

  //     var yTick = yAxis
  //       .selectAll("g")
  //       .data(y.ticks(5).slice(1))
  //       .enter().append("g");

  //     yTick.append("circle")
  //         .attr("fill", "none")
  //         .attr("stroke", "#000")
  //         .attr("r", y);

  //     yTick.append("text")
  //         .attr("y", function(d) { return -y(d); })
  //         .attr("dy", "0.35em")
  //         .attr("fill", "none")
  //         .attr("stroke", "#fff")
  //         .attr("stroke-width", 5)
  //         .text(y.tickFormat(5, "s"));

  //     yTick.append("text")
  //         .attr("y", function(d) { return -y(d); })
  //         .attr("dy", "0.35em")
  //         .text(y.tickFormat(5, "s"));

  //     yAxis.append("text")
  //         .attr("y", function(d) { return -y(y.ticks(5).pop()); })
  //         .attr("dy", "-1em")
  //         .text("Population");

  //     var legend = g.append("g")
  //       .selectAll("g")
  //       .data(data.columns.slice(1).reverse())
  //       .enter().append("g")
  //         .attr("transform", function(d, i) { return "translate(-40," + (i - (data.columns.length - 1) / 2) * 20 + ")"; });

  //     legend.append("rect")
  //         .attr("width", 18)
  //         .attr("height", 18)
  //         .attr("fill", z);

  //     legend.append("text")
  //         .attr("x", 24)
  //         .attr("y", 9)
  //         .attr("dy", "0.35em")
  //         .text(function(d) { return d; });
  // // });


}); 
  
}); 




</script>